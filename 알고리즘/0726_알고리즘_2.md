## 9:00 - 10:00 

---

### 실습 풀이 

### 코드 리뷰

1. 두개 뽑아서 더하기

   *  문제를 꼭 먼저 읽고 입출력 예시를 보자 
   * 값 두개 써놓고 가능한 조합 써놓기 
   * 0 => 1, 2, 3, 4,
   * 1 => 2,3,4
   * 2 => 3, 4
   * 3 => 4
   * 4 => x
   * 반복 두개 필요 0~4, 1~4
   * 프로그래머스 문제는 프로그래머스 환경에서 작업하자!!

   

2. 오엑스 퀴즈 

   * 헷갈리는게 있을 때는 그려보자
   * 문자열을 조건으로 써야 될 경우, 문자열을 변수에 저장함



## 10:00 - 11:00

---

### 알고리즘 평가/코드 평가

* 시간 복잡도 & 빅오 표기법

  * 좋은 알고리즘이란 무엇일까? == 효율성이 좋은 알고리즘? == 성능이 좋은 알고리즘? 

    > 인풋을 넣은 후 아웃풋이 나오는 시간이 짧은 알고리즘! 

  * 알고리즘의 소요 시간 측정하기

    * 객관적인 측정을 위해 알고리즘 내부에서 **기본연산이 몇번** 일어나는지 살펴본다. 
    * 알고리즘에서 시간은 실제 시간이 아니라 연산횟수 
    * 성능을 측정할 때는 입력 갯수에 따른 소요시간이 가장 큰 영향을 미침
    * n개에 따른 소요시간을 수식으로 가져감

  * 시간 복잡도란?

    > 단순하게 알고리즘의 수행시간을 의미
    >
    > 시간 복잡도가 높으면 느린 알고리즘
    >
    > 시간 복잡도가 낮으면 빠른 알고리즘



### 빅오 표기법

* 입력이 무한대로 커진다고 가정하고 시간 복잡도를 간단하게 표시하는 것 
* 최고차항만 남기고 계수와 상수 제거 => n = n < n제곱

![image-20220726105030010](0726_알고리즘_2.assets/image-20220726105030010.png)

* logN : 정렬 된 데이터셋에서 왔다갔다 하는 것이 이진 탐색이라고 함
  * 아무리 큰 데이터라 할지라도, 쭉 올라갔다가 어느 순간되서는 플랫한 형태로 진행 됨 
* n : 1중 for문
* NlogN : 높은 성능의 정렬
* n제곱: 2증 리스트 순회, 2중 for 문
* 같은 아웃풋을 만드는 알고리즘이라도 시간 복잡도에 따라 성능이 달라질 수 있고 시험에서 정답 여부가 갈리는 포인트가 됨



### 파이썬 내 시간 복잡도 

* 리뷰 단계에서 복잡도 고민하는 것
* 문제를 푼다음 시간 복잡도를 생각함
* 포문 안에 n의 내장함수 사용했다면 사실상 이중 포문과 다를 것이 없음
* copy : n
* **Append : 1**
* **Pop : 1**
* Sortt : n log n
* insert : n
* Containment : n

✔️반복

### 리스트

* 파이썬의 리스트가 어떻게 움직이는지? 

* 어떤 것을 조심해야 할지? 

* 배열 vs 연결 리스트(배열 보완)

  * 배열 : 여러 데이터들이 연속된 메모리 공간에 저장되어 있는 자료구조(파이썬 리스트가 배열에 좀 더 가까움)
  * 연결 리스트: 데이터가 담긴 여러 노드들이 순차적으로 연결 된 형태의 자료구조
  * 파이썬의 리스트는 배열의 장점과 연결 리스트의 장점을 모두 갖추고 있음
    * 인덱스 접근(배열의 약통과 비슷) + 가변길이

* 파이썬 리스트의 메서드

  * .append() : 리스트 맨 끝에 원소 삽입 => o(1), 요소 조회
  * .pop() : 특정 인덱스에 있는 원소를 삭제 및 반환 =>  o(1), 요소 조회
    * 팝은 리턴 값이 있음
  * 두개가 1인 이유는 한번씩 안가도 되기 때문

* 리스트를 수직으로 세워서 넣고 뺴는 통이라고 생각해도됨(스택, 책쌓여있는 통)

* 통의 갯수는 공간/메모리로 확인 가능하기 때문에 len 1임

* count는 세야되기 때문에 n임, 처음부터 끝까지

* 인덱스는 중간것을 찾아도 최악의 경우를 생각해야 되기 때문에(순회) 그래서 n

* sort는 리스트를 오름차순으로 정렬 n보다 좋지 않음

* reverse는 뒤집는 것이라서 n, 다 돌아야 되니깐 

* https://wiki.python.org/moin/TimeComplexity 참고

  

