## 9:00 - 10:00

---

* 델타탐색,배열에서 중요한 것은 dy, dx(델타 배열)를 만들어야함 
* 리스트의 범위를 벗어나면 안됨 
* 부순 차의 리스트를 만들어줌 
* 컨티뉴를 쓰는 이유 : 이 다음 반복문의 코드를 무시하고, 다음 값을탐색 
  * 쓰는 이유는? => 안되는 조건들을 세워놓고 컨티뉴를 하고 되는 조건들만 '
  * 성립이 안되는 조건들은 컨티뉴로 지나가고 조건이 성립 될 때만 정상적인 코드를 실행



## 그래프 탐색 알고리즘

* 관계와 연결이 중요 

* 데이터 구조는 알고리즘의 재료가 되어 문제를 해결하는데 사용된다 

* 깊이 우선 탐색, 너비 우선 탐색 

* 시작 정점에서 간선을 타고 이동할 수 있는 모든 정점을 찾는 알고리즘

  

### 깊이는 가장 멀리 있는 곳 까지 가보기 => dfs

* `스택의 개념을 활용`

* 갈데가 없으면 돌아감 

* 시작 정점으로부터 갈 수 있는 하위정점까지 가장 깊게 탐색 

* `더이상 갈 곳이 없다면 마지막 갈림길로 돌아와서 다른 정점을 탐색하며 결국 모든 정점을 방문하는 순회 방법`

* `미로 탈출과 동일`

* `모든 정점을 방문할 때 유리 따라서, 경우의 수와 순열 조합문제에서 많이사용`

* bfs에 비해 코드 구현이 간단

* 단, 모든 정점을 방문할 필요가 없거나 최단 거리를 구하는 경우에는 너비 우선 탐색이(bfs)

* 완전탐색의 하위개념

* 인접행렬, 인접리스트로 구현

  * 내가 돌아온 길을 보고 싶을때는 제외 로직을 파악해야 함

  * 각 정점을 방문했는지 여부를 판별할 방문 체크 리스트가 필요

  * 비지티드 리스트를 따로 선언하여 각 정점을 방문했는지 체크 

  * ```python
    visited = [false, false, ...] # false 리스트를 만듬
    viseted = [false] * n # n은 정점의 개수
    # 인덱스는 각 정점의 번호 
    # 방문한 곳은 true, 방문하지 않은 정점은 false
    # 0, 1 로 해도 상관 없음
    ```

  * `dfs의 사이클` 

    1. 현재 정점 방문처리 
    2. 인접한 모든 정점 확인 
    3. 방문하지 않은 인접 정점 이동

  * 반복문을 이용한 dfs

    * dfs는 직전에 방문한 정점으로 차례를 돌아가야 하므로, 후입선출 구조의 스택을 사용

      ```python
      visited = [false]*n # 방문 처리 리스트 만들기
      
      def dfs(start):
        stack = [시작 숫자] # 처음 시작 숫자이며, 돌아갈 곳을 기록하기 위해 스택에 넣어줌
        visited[start] = True # 시작 정점 방문 기록 
        
        while stack: #스택이 빌 때까지, 돌아갈 곳이 없을때까지 반복
          !cur =. stack.pop() # 현재 방문 정점(후입선출: 최근에 들어온 것 부터 먼저 나감)
          
          for i in graph[!cur]:# 인접한 모든 정점에 대해
            if not visited[i] : # 아직 방문하지 않았다면
              visited[i] = True # 방문 처리 
              stack.append(i) # 스택에 넣기
          
      ```

      * 왜 dfs 써야 하는가? 
        * 다 찾아본다는 소리  > for문으로 표현 못함? 
        * 끝까지 가보는 것 

### 너비는 옆에 있는 것들을 빠짐없이 보면서 가기 => bfs

* `큐의 개념을 활용`
* 인접해있는 애들부터 체크
* `최단거리 찾을 때 주로 샤용`



## 







