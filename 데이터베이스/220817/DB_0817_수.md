## 10:00 - 11:00

---

* 어제까지 배운 내용들
  * crud
  * 엑셀로 작업했을 때, 그 값들에 제약 조건이 없었다. (양식 없음)
  * 데이터 베이스로 넘어오면서 무결성, 데이터의 정보를 표로 표현하고 있음
  * 데이터베이스는 테이블 만들기 전에 스키마 만듬, 필드 별 타입 기록
  * 프라이머리 키, 낫널, 범위 등 > 제약 조건 만들 수 있음
  * 레코드 생성, 특정한 것을 수정, 삭제할 수 있음
  * 웹 개발 시, 버튼 누르면 게시글 삭제, 수정 할 수 있도록 프라이머리 키 활용해서 사용 가능



### where

* 테이블 [유저] 생성

* 사용할 수 있는 연산자

  * 비교연산자
    * =, >, >=,<=
  * 논리연산자 
    * And: 앞의 조건과 뒤에 조건 모두 ㅊ마인 경우
    * or: 앞의 조건이나 뒤의 조건이 참인 경우
    * not : 뒤에 오는 조건의 결과를 반대로

* 주의사항

  ![image-20220817104830630](DB_0817_화.assets/image-20220817104830630.png)

* between:
* in: 목록 중에 값이 하나라도 일치하면 성공
* like: 비교 문자열과 형태 일치
* is null /is not null
* ![image-20220817105148769](DB_0817_화.assets/image-20220817105148769.png)

그 where문 두 문장의 차이는 두번째 문장은 175면서 80인사람 이나 183이면서 80인 사람을 찾아주지만 첫번째 문장은 183이면서 80인 사람은 찾아주지만 키175인사람은 몸무게가 80아닌 것도 뽑아 낼 수 있기때문에 원하는 값을 못찾아줄수있다는 말인것 같습니다.



## 11:00- 12:00

---

* 집계함수 

  * 값 집합에 대한 계산을 수행하고 단일 값을 반환

* 예제

  * 계좌 잔액이 가장 높은 사람과 그 액수를 조회하려면? 

    ```sqlite
    select firstname, max(balance) from user d
    -- 질의한 것만 필드로 나옴, 컬렴명 추가해주어야함
    ```

		* **like**
		* 패턴일치를 기반으로 데이터를 조회하는 방법
		* % : 0개 이상의 문자 : 김으로 시작하는 사람 (김%)
		* _ : 임의의 단일 문자
		* 정규표현식 : 문자열 패턴 법칙 => 이메일



### oder by 

* 오름차순 디폴트 1,2,3,4 (asc)
* 내림차순 4,3,2,1(desc)
* 문자열 타입일 경우, 맨 앞글자 순으로 정렬 됨 
* 어떠한 조건과 상황에 맞는 데이터를 보고싶은 것 



### gitignore

* 이그노어할 파일을 이미 커밋한 상태에서 하면 의미없음
* 프로젝트 시작전에 해야함
* 용량 파일이 크다, 그럼 이그노어 파일 만들고 그 안에 파일명 입력



### 데이터 베이스 생성 정리

1. 데이터베이스 생성 
2. Csv 파일 넣기 => 테이블 생성 => 이런 경우, 맨 윗줄이 테이블 필드명이 됨
3. 만약, 테이블 생성에 필드명/제약 조건이 필요한 경우 
   1. 데이터베이스 생성
   2. 테이블 생성 = csv파일 정보를 테이블에 적용하기
   3. csv vkdlfdmf xpdlqmfdp wjrdyd

* 동일한 데이터 베이스 생성 시, 기존 것만 유지 됨(새로 생성 안됨)



### 연산 궁금한 것 정리

* 나누기는 몫만 나오기 때문에

```sqlite
CREATE TABLE users (
first_name TEXT NOT NULL,
last_name TEXT NOT NULL,
age INTEGER NOT NULL,
country TEXT NOT NULL,
phone TEXT NOT NULL,
balance INTEGER NOT NULL);
```

```python
T = 10 # 총 10개의 테스트케이스가 주어짐
for tc in range(1, T +1): # 10번 반복 
    N = int(input()) # 덤프 가능 횟수 넣기 
    numbers = list(map(int, input().split())) # 기둥들 높이를 받음
    for i in range(N): # 덤프 가능 횟수 만큼 반복
        max_num = max(numbers) # 가장 높은 기둥 높이, 예제 경우 처음 옆기둥
        min_num = min(numbers) # 가장 낮은 기둥 높이 
        index_max_num = numbers.index(max_num) # 가장 높은 기둥 높이의 자리(인덱스)숫자 구함 => 예제에서는 9의 자리가 6,7이고 그중 앞에 있는 것이 6임
        index_min_num = numbers.index(min_num) # 가장 낮은 기둥 높이의 자리(인덱스)숫자 구함 => 예제에서는 1의 자리가 3임
        numbers[index_max_num] -= 1 # 가장 높은 기둥자리 인덱스 6 자리에서 한개를 뺌
        numbers[index_min_num] += 1 # 가장 낮은 기둥자리 3에 1을 추가함
    print(f'#{tc} {max(numbers)-min(numbers)}')
```

