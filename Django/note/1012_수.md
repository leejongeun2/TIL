## Q&A

---

* Usercreationform의 custom

  > ⭐️Usercreationform 은 모델폼을 상속받아서 만들고 있다!! 
  >
  > * 우리가 모델폼을 정의할 떄 가장 중요했던 설정은? ===> 모델과 필드!!
  > * 모델에 클래스 정의하면 클래스 변수에 해당하는 것이 필드였음, 모델폼의 클래스 정의하면 클래스 변수에 해당 하는 것이 필드 html 필드
  > * 유저 크레이션 폼과 모델 폼은 어떤차이? 
  >   * 상속 관계 있음
  >   * 클래스 상속은 어떤 의미를 가지는지? 
  >     * 전에 만들어 놓은 클래스에서 만들어 놓은 기능을 새로운 클래스에서 사용하고 추가적으로 기능을 덧붙여쓸 수 있음
  >     * 클래스는 조작할 대상의 덩어리
  >     * 부모 클래스에 정의 된 속성/메서드(기능) 상속받아서 일부는 뜯어고치고, 일부는 추가할 수 있는 것
  > * 아티클 폼과 usercraeteform 차이는? 
  >   * 모델폼을 상속받은 것이 아티클폼, 유저 크리에이션폼
  >   * 모델폼에 인자로 request, post를 넣을 수 있었고 메타라는 것에 모델과 필드 정보를 담아 놓고 그것에 is_vaild를 가질 수 있었음
  >   * 모델폼을 상속받아서 아티클 폼은 다른 모델과 필드를 직접 정의하여 쓸 수 있음
  >   * 모델폼 태생을 보면 똑같이 정의, 활용할 수 있는데, 객체가 어떤 타입인지가 중요함
  >   *   modelform을 상속받는 건 공통점인데 UserCreationForm은 거기에 회원가입폼의 형태를 만들어주는 기능을 추가한 것?? 각자 추가한 기능이 다르다?
  >   * 둘의 차이는 필드의 구성과 모델의 구성이 달라진 것 뿐! 

* Get_user_model 사용 이유

  > 유저모델이라는게 결국에는 변경이 가능한 친구이면서 장고랑 사용자가 쓰는 것
  >
  > 결국에는 변경 가능한 것은 어찌 되었든지 변수화 등을 통해서 호출하도록 하는게 가장 좋다! 
  >
  > 범개발영역에서의 핵심 관통하는 내용
  >
  > 그래서 유저 모델 클래스는 어딘가에 있겠지만 이것을 get_user_mode()로 호출해서 쓰자 
  >
  > 그러면 알아서 auth_user_model에 정의 된 클래스를 준다

* accounts.user에 만들고 시작하는지? 왜 auth.user을 사용하지 않은지? 

  * Setting.py : auth_user_model 값 변경
  * accounts앱에 abstractuser을 상속받아 빈 껍데기를 만드는지?(pass)

  > 프로젝트를 시작한다면, 커스텀 유저 모델을 셋업하는 것을 추천한다. 
  >
  > 너가 기본 유저 모델이 충분하지라도..
  >
  > Why?나중에 필요한순간이 되었을때, 그때 커스텀이 가능하게끔 하기 위해서! 
  >
  > 마이그레이트 하기 전에 해라!
  >
  > 프로젝트 중간에 변경하고 싶다면 어려운 이유가 외래키나 관계에서 문제가 발생할 수 있고 자동적으로 들어가지 않고 스키마를 변경하거나 테이블에 있는 값을 이동시키는 작업을 진행해야함 => 모델은 디비를 조작하는데 밀접한 관계를 가지고 있어서, 모델의 필드가 수정되거나 하는 것들은 마이그레이션 파일등을 통해서 자동으로 관리 되는데, 모델 자체가 변화하면 별도의 수작업이 필요
  >
  > ⚠️결론: 우리는 장고 내부가 아닌 어카운트 유저를 만들고 간다!!

  * user가 아닌 abstractuser을 상속받는이유는? 

    > 유저를 똑같이 쓰고싶은데 유저를 유저로 상속받는것이 아니라 유저가 상속받고 있는것을 받으면 똑같은 상황임



* 가장핵심 비밀번호, 사용자들에게 받은 값을 저장하면 안되고, `암호화`하는 과정이 필요함 
* 사용자를 관리한다는 것은 어려움이 있음



### 심화

* 유저를 변경할 것임 vs 게시글 변경
  * ⚠️유저 변경할 이때 중요한 것은 패스워드!!
  * 그렇기 때문에 비밀번호 변경은 다른 페이지 인 경우가 많음
  * 암호화해서 저장해야 되기 떄문
  * 유저 체인지폼과 셋패스워드폼을 가지고 있음(사용자 변경과 암호변경을 별도로 가져갈 수 있다)
    * 유저 체인지 폼은 모델폼일까? 아닐까? ==> 모델폼 맞음
    * 셋패스워드폼은 모델폼일까 아닐까? ==> 모델폼 아님, 폼즈 닷 폼임, 모델과 연결되어있지 않음
    * 장고에는 모델폼이 있고, 그냥 폼 두개가 존재
      * 모델폼은 모델의 필드를 의미할때



### 로그인에 대한 이해

* 내가 누구인지를 알고 있다!
* 클라이언트와 서버가 어떻게 동작하고 있을까? 
  * 요청과 응답
  * 클라이어트와 서버 간의 약속 : http
* 비 연결 지향
  * 요청 보내고 서버가 응답하고 끝
  * 네이버 서버는 우리에게 메인 페이지를 응답하고 연결을 끊는 것 
* 무상태
  * 연결을 끊는 순간 클라이언트와 서버 간의 통신이 끝나며 상태 정보가 유지되지 않음
* 어떻게 로그인 상태를 유지할까? 
  * 로그인하고 웹 사이트를 사용할 때 페이지를 이동해도 로그인 상태가 유지 됨
  * 서버와 클라이언트 간 지속적인 상태 유지를위해 `쿠키와 세션`이 존재하기 때문



### 쿠키란? 

> 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각
>
> 사용자가 웹 사이트를 방문할 경우 해당 웹사이트의 서버를 통해 사용자의 컴퓨터에 설치되는 작은 기록 정보 파일
>
> 쿠팡 서버가 떨어뜨려 놓은 쿠키를 먹어버리면 장바구니가 비어져있음
>
> 개발자 도구 > 네트워크 > 스토리지 > 쿠키 > 쿠팡에서 떨어뜨려 놓은 쿠키 정보를 볼 수 있음
>
> 쿠팡이 서버에서 응답을 해주면서 브라우저에 떨어뜨려 놓고 간 것이 쿠키 



### 쿠키 사용목적

* 세션관리 
  * 로그인, 아이디 자동완성, 공지 하루 안보기, 팝업 체크, 장바구니 등의 정보 관리
* 개인화 
  * 사용자 선호, 다크모드 등
* 트래킹 



### 세션이란? 

* 서버에 특정한 값을 저장해놓고 쿠키에 던저줄때 그 세션에 대한 정보를 담아서 주기도함 
* 사이트와 특정 브라우저 사이의 상태를 유지시키는 것 
* 서버 자체에 어느 곳에서 저장을 하고 있게 됨 => 서버의 리소스를 활용함
* 서버의 리소스를 써더라도 유지를 하고 싶은 정보는 서버 사이드에서 저장을 함 



### 쿠키수명

* 현재 세션이 종료 되면 삭제되는 세션 쿠키가 있음
* persistent cookie
  * Expires 속성에 지정 된 날짜 혹은 max_age속성에 저장된 기간이 지나면 삭제됨 
* 쿠키를 남기지 않으려면 시크릿 모드

### 장고 세션관리

* 데이터베이스 기본으로 세션 테이블을 만들고 관리 
* ⚠️어드민에 로그인이 되어있다는 것은, 디비의 세션에 저장이 되어있다라는 사실!
  * 로그아웃 하면 세션 비워짐
* 요청이 들어오면 미들웨어 위에서 밑으로, 응답을 하면 아래에서 위로(역순)                                                                                                                                                                                                                                                                                                                                                                                   



### 로그인 로직(기능)

### 아래의 로직은 어떤 로직과 비슷할까? ==>> article create / user create 와 비슷함!! 

1. Url: GET/accounts/login/
2. 처리를 어떻게 할껀지? 
   1. 사용자에게 폼을 제공
3.  Url: POST/accounts/login/
4. 처리
   1. 로그인 로직처리
      1. 사용자인지 확인하고 장고 테이블에 저장, 쿠키 주기
   2. 게시글 목록 페이지로 리다이렉트



* authenticationform은 모델 폼이 아니었음
  * 로그인로직에 모델과 관련 된 얘기를 한적이 없음
  * forms.form을 상속 받고 있음
  * 그러다보니까 init에서 생성자의 첫번째 리퀘스트 내놔, 두번째에 data키워드 알규멘트로 리퀘스트 포스트
  * 그래서 세이브도 없음
    * 그럼 세이브 자리에 어떤 것을 놓아야할까?? => 세션에 저장, login(request, form.get_user())

* 리퀘스트 유저는 is_authenticated라는 속성이 있음
* 로그인을 한 상태에서는 로그인페이지로 갈 수 있는지? 
* 글쓰기도 회원만 가능하게끔
  * url로도 못넘어오게끔 서버사이드에서 막아줘야함
  * 뷰에서 조건문을 걸음
    * url로 넘어갈 때 ㅇ오류 뜸 => 해결책은 else에 리턴 렌더 또는 리턴 리다이렉트(로그인 창)



* 수정페이지



## 코드 실행 순서

1. 버튼을 안만들어놨는데, url로 직접 접근할 수 있음 , 어디서 막을 것이냐? 
2. 서버에서 막아두면 된다 (뷰)
3. 인증여부를 직접 조건문 
   1. @login_required 데코레이터를 쓸 수 있음 => 아래와 같은 ur로 로그인 페이지로 보내
   2. accouts/login/?next/ariticle/1/updqte
4. 사용자가 로그인 html 폼을 보고 내용을 채우고 로그인 버튼을 누름
5. 그때, url: post 위 유알에임
6. 뷰: 로그인 실행 됨
7. If t실행 됨
8. form 하고 
   1. 
9. is form vaild 할 것임



세션 테이블에 뭔갈 저장하고 쿠키 떨궈주고 리퀘스트 객체고, 로그인과 관련된 어센틱 폼 활용, 모델 폼 아니라서 인자 다르지만 로그인 함수 코드, 사인업 함수 코드, 크리에이트 함수 코드 로직 동일, 



### 깃헙플로우

1. 마스터(메인) 브랜치에서 새로운 브런치를 만든다. 
   1. 상세하게 작성
   2. git branch 



## 실습

---

1. 어드민 접속
2. 로그인 되어있다면 db> 장고 세션 테이블(모델) > 저장이 되어있음
3. 로그아웃 하면 > 디비 비어있음
   1. 알수 있는 사실: 장고는 다 알아서 도와주고 있다. 
4. setting의 인스톨 앱 에서 세션 관리 확인할 수 있음
5. 그 밑에 미들웨어는 

